var exports = module.exports = {};
var maze = new Object();

var currentNode = new Object();
var firstNode = new Object();
var endNode = new Object();
var nodeArray = [[],[]];
var nextNodeList = [];
var nodeNumber = 0;
var visitedList = [];

exports.solveMaze = function(mazeArray){
	maze.height = mazeArray.length;
	maze.width = mazeArray[1].length;

	for (var y = 0; y < maze.height; y++){
		nodeArray[y] = []
		for (var x = 0; x < maze.width; x++){
			var node = new Object();
			node.xVal = x;
			node.yVal = y;
			node.visited = 0;
			node.number = -1;
			node.character = mazeArray[y][x];
			nodeArray[y][x] = node;
		}
	}

	//find starting point
	currentNode = findStartingPosition(nodeArray);

	while (currentNode.character != 'B')
	{
		currentNode.number = nodeNumber;
		nodeNumber++;

		visitedList.push(currentNode);
		move(currentNode);
		currentNode = nextNodeList[0];
		nextNodeList.shift();
	}

	//Node number for the final position
	currentNode.number = nodeNumber;
	endNode.number = currentNode.number;

	var bestpath = [];
	while(currentNode.character != 'A'){
		bestpath.push(currentNode);
		if(currentNode.character != 'B'){
			currentNode.character = '@';
		}
		currentNode = getLowestNeighbor(currentNode);
	}

	//write file with shortest path
	return nodeArray;
}

function getLowestNeighbor(currentPathNode){
	var neighborValues = [currentPathNode.number, currentPathNode.number, currentPathNode.number, currentPathNode.number];

	var rightNeighbor = new Object();
	if(currentPathNode.xVal+1 <= maze.width){
		rightNeighbor = nodeArray[currentPathNode.yVal][currentPathNode.xVal+1]
		if(rightNeighbor.visited == 1){
			neighborValues[0] = rightNeighbor.number;
		}
	}

	// down neighbor, neighborValues[1]
	var downNeighbor = new Object();
	if(currentPathNode.yVal+1 <= maze.height){
		downNeighbor = nodeArray[currentPathNode.yVal+1][currentPathNode.xVal]
		if(downNeighbor.visited == 1){
			neighborValues[1] = downNeighbor.number;
		}
	}

	// left neighbor, neighborValues[2]
	var leftNeighbor = new Object();
	if(currentPathNode.xVal-1 >= 0){
		leftNeighbor = nodeArray[currentPathNode.yVal][currentPathNode.xVal-1]
		if(leftNeighbor.visited == 1){
			neighborValues[2] = leftNeighbor.number;
		}
	}

	// up neighbor, neighborValues[3]
	var upNeighbor = new Object();
	if(currentPathNode.yVal-1 >= 0){
		upNeighbor = nodeArray[currentPathNode.yVal-1][currentPathNode.xVal]
		if(upNeighbor.visited == 1){
			neighborValues[3] = upNeighbor.number;
		}
	}

	var min = currentPathNode.number;
	var minIndex = 0;

	for (var i = 1; i < neighborValues.length; i++) {
		if (neighborValues[i] < min) {
			minIndex = i;
			min = neighborValues[i];
		}
	}

	if(minIndex == 0){
		return rightNeighbor;
	}

	if(minIndex == 1){
		return downNeighbor;
	}

	if(minIndex == 2){
		return leftNeighbor;
	}

	if(minIndex == 3){
		return upNeighbor;
	}
}

function findStartingPosition(nodeArray){
	for (var y = 0; y < maze.height; y++){
		for (var x = 0; x < maze.width; x++){
			firstNode = nodeArray[y][x];
			if(firstNode.character == 'A'){
				firstNode.visited = 1;
				return firstNode;
			}
		}
	}
}

function move(currentNode){
	// x val < max --> move right
	if(currentNode.xVal < maze.width-1)
	{
		var rightNode = nodeArray[currentNode.yVal][currentNode.xVal+1];
		if (isValidNode(rightNode))
		{
			nextNodeList.push(rightNode)
		}
	}

	// yval > 0 --> move down
	if(currentNode.yVal < maze.height-1)
	{
		var downNode = nodeArray[currentNode.yVal+1][currentNode.xVal];
		if (isValidNode(downNode))
		{
			nextNodeList.push(downNode)
		}
	}
	// x val > 0 --> move left
	if(currentNode.xVal > 0)
	{
		var leftNode = nodeArray[currentNode.yVal][currentNode.xVal-1];
		if (isValidNode(leftNode))
		{
			nextNodeList.push(leftNode)
		}
	}
	// yVal < max --> move down
	if(currentNode.yVal > 0)
	{
		var upNode = nodeArray[currentNode.yVal-1][currentNode.xVal];
		if (isValidNode(upNode))
		{
			nextNodeList.push(upNode)
		}
	}
}

function isValidNode(possibleNode){
	if(possibleNode.yVal < maze.height && possibleNode.xVal < maze.width){
		if(possibleNode.character != '#'){
			if(!possibleNode.visited){
				possibleNode.visited = 1;
				return true;
			}
		}
	}
	return false;
}
